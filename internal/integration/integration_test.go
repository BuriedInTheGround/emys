package integration_test

import (
	"bytes"
	"testing"

	"interrato.dev/emys/internal/ahe"
	"interrato.dev/emys/internal/ahmac"
)

func TestIntegration(t *testing.T) {
	key1, err := ahe.KeyFromSeed([]byte("YELLOW SUBMARINE, BLACK WIZARDRY"), 3)
	if err != nil {
		t.Fatal(err)
	}
	key2, err := ahe.KeyFromSeed([]byte("BLACK WIZARDRY, YELLOW SUBMARINE"), 3)
	if err != nil {
		t.Fatal(err)
	}
	key3 := make([]byte, ahe.BlockSize*3)
	if err := ahe.Add(key3, key1); err != nil {
		t.Fatal(err)
	}
	if err := ahe.Add(key3, key2); err != nil {
		t.Fatal(err)
	}

	plaintext1 := []byte{
		0x00,
		0x88, 0x0a, 0xdc, 0x67, 0x47, 0x24, 0x93, 0x50,
		0x5e, 0x60, 0x1c, 0x8d, 0xaf, 0xd1, 0x62, 0x03,
		0xd4, 0x13, 0xb2, 0x6d, 0xf9, 0x08, 0x01, 0x76,
		0x30, 0xf3, 0x80, 0x9d, 0x8c, 0x03, 0x73, 0x00,
		0x00,
		0xf1, 0xda, 0x7a, 0xd0, 0x1f, 0xc6, 0xa7, 0xea,
		0xb8, 0x2d, 0x7c, 0x78, 0x1a, 0xc3, 0x34, 0xa3,
		0xeb, 0x11, 0xa0, 0x54, 0xe2, 0x1b, 0xd0, 0xb8,
		0xea, 0xd2, 0x31, 0xc0, 0xf9, 0xf0, 0x94, 0x5b,
		0x00,
		0x73, 0x24, 0x5e, 0x83, 0x65, 0x9e, 0xf1, 0x73,
		0x75, 0xaa, 0x3b, 0x4b, 0x13, 0x2f, 0x38, 0x86,
		0x9d, 0xfa, 0xbd, 0xd2, 0xbd, 0x8f, 0x89, 0x44,
		0x10, 0x4e, 0x1a, 0xef, 0x80, 0x62, 0x60, 0xaa,
	}
	plaintext2 := []byte{
		0x00,
		0x61, 0x0e, 0x1c, 0x3c, 0x6c, 0xd4, 0xb1, 0x32,
		0x4f, 0x29, 0x0f, 0x43, 0x44, 0xa2, 0x6f, 0x25,
		0x04, 0x12, 0xa8, 0x5e, 0x5c, 0x69, 0xd1, 0x59,
		0xb6, 0x24, 0x89, 0xe1, 0xa8, 0x1e, 0x79, 0x1f,
		0x00,
		0x02, 0x41, 0x0b, 0x4f, 0x2e, 0xb5, 0xc4, 0xba,
		0x73, 0x92, 0x02, 0x16, 0x97, 0x4a, 0x1c, 0x39,
		0x92, 0x1a, 0xdc, 0x16, 0x71, 0x27, 0x3d, 0x13,
		0xf0, 0xed, 0x63, 0xe3, 0x65, 0x69, 0x16, 0xc5,
		0x00,
		0xae, 0xdd, 0xeb, 0x27, 0xa0, 0xdb, 0x53, 0x28,
		0xb1, 0x27, 0x3e, 0x9c, 0xe6, 0xa9, 0x69, 0x46,
		0x5d, 0x08, 0x0b, 0x57, 0x87, 0xb4, 0xbd, 0xca,
		0xae, 0x76, 0x6e, 0xdd, 0xd2, 0xce, 0xd9, 0x77,
	}
	plaintext3 := make([]byte, ahe.BlockSize*3)
	if err := ahe.Add(plaintext3, plaintext1); err != nil {
		t.Fatal(err)
	}
	if err := ahe.Add(plaintext3, plaintext2); err != nil {
		t.Fatal(err)
	}

	ciphertext1, err := ahe.Encrypt(key1, plaintext1)
	if err != nil {
		t.Fatal(err)
	}
	ciphertext2, err := ahe.Encrypt(key2, plaintext2)
	if err != nil {
		t.Fatal(err)
	}
	ciphertext3 := make([]byte, ahe.BlockSize*3)
	if err := ahe.Add(ciphertext3, ciphertext1); err != nil {
		t.Fatal(err)
	}
	if err := ahe.Add(ciphertext3, ciphertext2); err != nil {
		t.Fatal(err)
	}

	ikey := ahmac.UniformKey([]byte("YELLOW SUBMARINE, BLACK WIZARDRY"))
	akey1 := ahmac.UniformKey(bytes.Repeat([]byte{0x01}, 32))
	akey2 := ahmac.UniformKey(bytes.Repeat([]byte{0x02}, 32))
	akey3 := make([]byte, ahmac.Size)
	if err := ahmac.Add(akey3, akey1); err != nil {
		t.Fatal(err)
	}
	if err := ahmac.Add(akey3, akey2); err != nil {
		t.Fatal(err)
	}

	tag1, err := ahmac.MAC(ikey, akey1, ciphertext1)
	if err != nil {
		t.Fatal(err)
	}
	tag2, err := ahmac.MAC(ikey, akey2, ciphertext2)
	if err != nil {
		t.Fatal(err)
	}
	tag3 := make([]byte, ahmac.Size)
	if err := ahmac.Add(tag3, tag1); err != nil {
		t.Fatal(err)
	}
	if err := ahmac.Add(tag3, tag2); err != nil {
		t.Fatal(err)
	}

	tag3Want, err := ahmac.MAC(ikey, akey3, ciphertext3)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(tag3, tag3Want) {
		t.Errorf("got %x, want %x", tag3, tag3Want)
	}
}
