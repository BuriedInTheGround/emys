package bitset_test

import (
	"bytes"
	"testing"

	"interrato.dev/emys/internal/bitset"
)

func TestSet(t *testing.T) {
	bs := bitset.New(550)
	for i := range 550 {
		if err := bs.Set(uint64(i)); err != nil {
			t.Fatal(err)
		}
	}
	b := bs.Bytes()
	want := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,

		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}
	if !bytes.Equal(b, want) {
		t.Errorf("got %x, want %x", b, want)
	}
}

func TestBitsAt(t *testing.T) {
	b := bitset.New(300)
	b.Set(1)
	b.Set(4)
	b.Set(10)
	b.Set(12)
	b.Set(13)
	b.Set(17)
	b.Set(19)
	b.Set(24)
	b.Set(26)
	b.Set(31)
	b.Set(280)
	b.Set(283)
	b.Set(289)
	b.Set(290)
	tests := []struct {
		from   uint64
		amount uint64
		want   []byte
	}{
		{from: 4, amount: 9, want: []byte{0x01, 0x41}},
		{from: 5, amount: 24, want: []byte{0x28, 0x51, 0xa0}},
		{from: 19, amount: 13, want: []byte{0x10, 0xa1}},
		{from: 276, amount: 15, want: []byte{0x60, 0x90}},
	}
	for _, tt := range tests {
		got, err := b.BitsAt(tt.from, tt.amount)
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(got, tt.want) {
			t.Errorf("BitsAt(%d, %d) = %x, want %x", tt.from, tt.amount, got, tt.want)
		}
	}
}

func TestNeg(t *testing.T) {
	bs := bitset.New(300)
	bs.Set(0)
	bs.Set(2)
	bs.Set(6)
	bs.Set(10)
	bs.Set(11)
	bs.Set(16)
	bs.Set(17)
	bs.Set(18)
	bs.Set(259)
	bs.Set(268)
	bs.Set(277)
	bs.Set(280)
	bs.Set(281)
	bs.Set(282)
	bs.Set(284)
	bs.Set(286)
	bs.Set(288)
	bs.Set(289)
	bs.Set(291)
	bs.Set(296)
	bs.Set(297)
	err := bs.Neg()
	if err != nil {
		t.Fatal(err)
	}
	b := bs.Bytes()
	want := []byte{
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf4, 0xa8, 0xdf, 0xef, 0xf7,

		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf3, 0xba,
	}
	if !bytes.Equal(b, want) {
		t.Errorf("got %x, want %x", b, want)
	}
}
